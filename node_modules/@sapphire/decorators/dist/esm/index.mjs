import { isDMChannel, isGuildBasedChannel } from '@sapphire/discord.js-utilities';
import { UserError, container } from '@sapphire/framework';
import { isNullish } from '@sapphire/utilities';
import { PermissionsBitField, PermissionFlagsBits } from 'discord.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/utils.ts
function createMethodDecorator(fn) {
  return fn;
}
__name(createMethodDecorator, "createMethodDecorator");
function createClassDecorator(fn) {
  return fn;
}
__name(createClassDecorator, "createClassDecorator");
function createFunctionPrecondition(precondition, fallback = () => void 0) {
  return createMethodDecorator((_target, _propertyKey, descriptor) => {
    const method = descriptor.value;
    if (!method)
      throw new Error("Function preconditions require a [[value]].");
    if (typeof method !== "function")
      throw new Error("Function preconditions can only be applied to functions.");
    descriptor.value = /* @__PURE__ */ __name(async function descriptorValue(...args) {
      const canRun = await precondition(...args);
      return canRun ? method.call(this, ...args) : fallback.call(this, ...args);
    }, "descriptorValue");
  });
}
__name(createFunctionPrecondition, "createFunctionPrecondition");
function createProxy(target, handler) {
  return new Proxy(target, {
    ...handler,
    get: (target2, property) => {
      const value = Reflect.get(target2, property);
      return typeof value === "function" ? (...args) => value.apply(target2, args) : value;
    }
  });
}
__name(createProxy, "createProxy");

// src/base-decorators.ts
function Enumerable(value) {
  return (target, key) => {
    Reflect.defineProperty(target, key, {
      enumerable: value,
      set(val) {
        Reflect.defineProperty(this, key, {
          configurable: true,
          enumerable: value,
          value: val,
          writable: true
        });
      }
    });
  };
}
__name(Enumerable, "Enumerable");
function EnumerableMethod(value) {
  return createMethodDecorator((_target, _propertyKey, descriptor) => {
    descriptor.enumerable = value;
  });
}
__name(EnumerableMethod, "EnumerableMethod");
var DecoratorIdentifiers = /* @__PURE__ */ ((DecoratorIdentifiers2) => {
  DecoratorIdentifiers2["RequiresClientPermissionsGuildOnly"] = "requiresClientPermissionsGuildOnly";
  DecoratorIdentifiers2["RequiresClientPermissionsMissingPermissions"] = "requiresClientPermissionsMissingPermissions";
  DecoratorIdentifiers2["RequiresUserPermissionsGuildOnly"] = "requiresUserPermissionsGuildOnly";
  DecoratorIdentifiers2["RequiresUserPermissionsMissingPermissions"] = "requiresUserPermissionsMissingPermissions";
  return DecoratorIdentifiers2;
})(DecoratorIdentifiers || {});
var DMAvailablePermissions = new PermissionsBitField(
  ~new PermissionsBitField([
    //
    PermissionFlagsBits.AddReactions,
    PermissionFlagsBits.AttachFiles,
    PermissionFlagsBits.EmbedLinks,
    PermissionFlagsBits.ReadMessageHistory,
    PermissionFlagsBits.SendMessages,
    PermissionFlagsBits.UseExternalEmojis,
    PermissionFlagsBits.ViewChannel
  ]).bitfield & PermissionsBitField.All
);
var DMAvailableUserPermissions = new PermissionsBitField(
  ~new PermissionsBitField([
    PermissionFlagsBits.AddReactions,
    PermissionFlagsBits.AttachFiles,
    PermissionFlagsBits.EmbedLinks,
    PermissionFlagsBits.ReadMessageHistory,
    PermissionFlagsBits.SendMessages,
    PermissionFlagsBits.UseExternalEmojis,
    PermissionFlagsBits.ViewChannel,
    PermissionFlagsBits.UseExternalStickers,
    PermissionFlagsBits.MentionEveryone
  ]).bitfield & PermissionsBitField.All
);
var RequiresClientPermissions = /* @__PURE__ */ __name((...permissionsResolvable) => {
  const resolved = new PermissionsBitField(permissionsResolvable);
  const resolvedIncludesServerPermissions = Boolean(resolved.bitfield & DMAvailablePermissions.bitfield);
  return createFunctionPrecondition((context) => {
    const { channel } = context;
    const member = context.guild?.members.me;
    if (resolvedIncludesServerPermissions && isDMChannel(channel)) {
      throw new UserError({
        identifier: "requiresClientPermissionsGuildOnly" /* RequiresClientPermissionsGuildOnly */,
        message: "Sorry, but that command can only be used in a server because I do not have sufficient permissions in DMs"
      });
    }
    if (isGuildBasedChannel(channel) && !isNullish(member)) {
      const missingPermissions = channel.permissionsFor(member).missing(resolved);
      if (missingPermissions.length) {
        throw new UserError({
          identifier: "requiresClientPermissionsMissingPermissions" /* RequiresClientPermissionsMissingPermissions */,
          message: `Sorry, but I am not allowed to do that. I am missing the permissions: ${missingPermissions}`,
          context: {
            missing: missingPermissions
          }
        });
      }
    }
    return true;
  });
}, "RequiresClientPermissions");
var RequiresUserPermissions = /* @__PURE__ */ __name((...permissionsResolvable) => {
  const resolved = new PermissionsBitField(permissionsResolvable);
  const resolvedIncludesServerPermissions = Boolean(resolved.bitfield & DMAvailableUserPermissions.bitfield);
  return createFunctionPrecondition((context) => {
    const { channel } = context;
    const member = context.guild?.members.me;
    if (resolvedIncludesServerPermissions && isDMChannel(channel)) {
      throw new UserError({
        identifier: "requiresUserPermissionsGuildOnly" /* RequiresUserPermissionsGuildOnly */,
        message: "Sorry, but that command can only be used in a server because you do not have sufficient permissions in DMs"
      });
    }
    if (isGuildBasedChannel(channel) && !isNullish(member)) {
      const missingPermissions = channel.permissionsFor(member).missing(resolved);
      if (missingPermissions.length) {
        throw new UserError({
          identifier: "requiresUserPermissionsMissingPermissions" /* RequiresUserPermissionsMissingPermissions */,
          message: `Sorry, but you are not allowed to do that. You are missing the permissions: ${missingPermissions}`,
          context: {
            missing: missingPermissions
          }
        });
      }
    }
    return true;
  });
}, "RequiresUserPermissions");
function RequiresGuildContext(fallback = () => void 0) {
  return createFunctionPrecondition((context) => context.guild !== null, fallback);
}
__name(RequiresGuildContext, "RequiresGuildContext");
function RequiresDMContext(fallback = () => void 0) {
  return createFunctionPrecondition((context) => context.guild === null, fallback);
}
__name(RequiresDMContext, "RequiresDMContext");
function ApplyOptions(optionsOrFn) {
  return createClassDecorator(
    (target) => createProxy(target, {
      construct: (ctor, [context, baseOptions = {}]) => new ctor(context, {
        ...baseOptions,
        ...typeof optionsOrFn === "function" ? optionsOrFn({ container, context }) : optionsOrFn
      })
    })
  );
}
__name(ApplyOptions, "ApplyOptions");

export { ApplyOptions, DecoratorIdentifiers, Enumerable, EnumerableMethod, RequiresClientPermissions, RequiresDMContext, RequiresGuildContext, RequiresUserPermissions, createClassDecorator, createFunctionPrecondition, createMethodDecorator, createProxy };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map