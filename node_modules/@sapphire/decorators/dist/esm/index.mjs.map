{"version":3,"sources":["../../src/utils.ts","../../src/base-decorators.ts","../../src/djs-decorators.ts","../../src/piece-decorators.ts"],"names":["target","DecoratorIdentifiers"],"mappings":"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","sourcesContent":["/**\n * The function precondition interface.\n */\nexport interface FunctionPrecondition {\n\t/**\n\t * The arguments passed to the function or class' method.\n\t */\n\t(...args: any[]): boolean | Promise<boolean>;\n}\n\n/**\n * The fallback interface, this is called when the function precondition returns or resolves with a falsy value.\n */\nexport interface FunctionFallback {\n\t/**\n\t * The arguments passed to the function or class' method.\n\t */\n\t(...args: any[]): unknown;\n}\n\n/**\n * Utility to make a method decorator with lighter syntax and inferred types.\n *\n * ```typescript\n * // Enumerable function\n *\tfunction enumerableMethod(value: boolean) {\n *\t\treturn createMethodDecorator((_target, _propertyKey, descriptor) => {\n *\t\t\tdescriptor.enumerable = value;\n *\t\t});\n *\t}\n * ```\n * @param fn The method to decorate\n */\nexport function createMethodDecorator(fn: MethodDecorator): MethodDecorator {\n\treturn fn;\n}\n\n/**\n * Utility to make a class decorator with lighter syntax and inferred types.\n * @param fn The class to decorate\n * @see {@link ApplyOptions}\n */\nexport function createClassDecorator<TFunction extends (...args: any[]) => void>(fn: TFunction): ClassDecorator {\n\treturn fn;\n}\n\n/**\n * Utility to make function preconditions.\n *\n * ```typescript\n * // No fallback (returns undefined)\n * function requireGuild(value: number) {\n *   return createFunctionPrecondition((message: Message) =>\n *     message.guild !== null\n *   );\n * }\n *\n * // With fallback\n * function requireGuild(\n *   value: number,\n *   fallback: () => unknown = () => undefined\n * ) {\n *   return createFunctionPrecondition(\n *     (message: Message) => message.guild !== null,\n *     fallback\n *   );\n * }\n * ```\n * @since 1.0.0\n * @param precondition The function that defines whether or not the function should be run, returning the returned value from fallback\n * @param fallback The fallback value that defines what the method should return in case the precondition fails\n */\nexport function createFunctionPrecondition(precondition: FunctionPrecondition, fallback: FunctionFallback = (): void => undefined): MethodDecorator {\n\treturn createMethodDecorator((_target, _propertyKey, descriptor) => {\n\t\tconst method = descriptor.value;\n\t\tif (!method) throw new Error('Function preconditions require a [[value]].');\n\t\tif (typeof method !== 'function') throw new Error('Function preconditions can only be applied to functions.');\n\n\t\tdescriptor.value = async function descriptorValue(this: (...args: any[]) => any, ...args: any[]) {\n\t\t\tconst canRun = await precondition(...args);\n\t\t\treturn canRun ? method.call(this, ...args) : fallback.call(this, ...args);\n\t\t} as unknown as undefined;\n\t});\n}\n\n/**\n * Creates a new proxy to efficiently add properties to class without creating subclasses\n * @param target The constructor of the class to modify\n * @param handler The handler function to modify the constructor behavior for the target\n * @hidden\n */\nexport function createProxy<T extends object>(target: T, handler: Omit<ProxyHandler<T>, 'get'>): T {\n\treturn new Proxy(target, {\n\t\t...handler,\n\t\tget: (target, property) => {\n\t\t\tconst value = Reflect.get(target, property);\n\t\t\treturn typeof value === 'function' ? (...args: readonly unknown[]) => value.apply(target, args) : value;\n\t\t}\n\t});\n}\n","import type { NonNullObject } from '@sapphire/utilities';\nimport { createMethodDecorator } from './utils';\n\n/**\n * Decorator that sets the enumerable property of a class field to the desired value.\n * @param value Whether the property should be enumerable or not\n */\nexport function Enumerable(value: boolean) {\n\treturn (target: unknown, key: string) => {\n\t\tReflect.defineProperty(target as NonNullObject, key, {\n\t\t\tenumerable: value,\n\t\t\tset(this: unknown, val: unknown) {\n\t\t\t\tReflect.defineProperty(this as NonNullObject, key, {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: value,\n\t\t\t\t\tvalue: val,\n\t\t\t\t\twritable: true\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n}\n\n/**\n * Decorator that sets the enumerable property of a class method to the desired value.\n * @param value Whether the method should be enumerable or not\n */\nexport function EnumerableMethod(value: boolean) {\n\treturn createMethodDecorator((_target, _propertyKey, descriptor) => {\n\t\tdescriptor.enumerable = value;\n\t});\n}\n","import { isDMChannel, isGuildBasedChannel } from '@sapphire/discord.js-utilities';\nimport { UserError } from '@sapphire/framework';\nimport { isNullish } from '@sapphire/utilities';\nimport { PermissionFlagsBits, PermissionsBitField, type BaseInteraction, type Message, type PermissionResolvable } from 'discord.js';\nimport { createFunctionPrecondition, type FunctionFallback } from './utils';\n\nexport enum DecoratorIdentifiers {\n\tRequiresClientPermissionsGuildOnly = 'requiresClientPermissionsGuildOnly',\n\tRequiresClientPermissionsMissingPermissions = 'requiresClientPermissionsMissingPermissions',\n\tRequiresUserPermissionsGuildOnly = 'requiresUserPermissionsGuildOnly',\n\tRequiresUserPermissionsMissingPermissions = 'requiresUserPermissionsMissingPermissions'\n}\n\nconst DMAvailablePermissions = new PermissionsBitField(\n\t~new PermissionsBitField([\n\t\t//\n\t\tPermissionFlagsBits.AddReactions,\n\t\tPermissionFlagsBits.AttachFiles,\n\t\tPermissionFlagsBits.EmbedLinks,\n\t\tPermissionFlagsBits.ReadMessageHistory,\n\t\tPermissionFlagsBits.SendMessages,\n\t\tPermissionFlagsBits.UseExternalEmojis,\n\t\tPermissionFlagsBits.ViewChannel\n\t]).bitfield & PermissionsBitField.All\n);\n\nconst DMAvailableUserPermissions = new PermissionsBitField(\n\t~new PermissionsBitField([\n\t\tPermissionFlagsBits.AddReactions,\n\t\tPermissionFlagsBits.AttachFiles,\n\t\tPermissionFlagsBits.EmbedLinks,\n\t\tPermissionFlagsBits.ReadMessageHistory,\n\t\tPermissionFlagsBits.SendMessages,\n\t\tPermissionFlagsBits.UseExternalEmojis,\n\t\tPermissionFlagsBits.ViewChannel,\n\t\tPermissionFlagsBits.UseExternalStickers,\n\t\tPermissionFlagsBits.MentionEveryone\n\t]).bitfield & PermissionsBitField.All\n);\n\n/**\n * Allows you to set permissions required for individual methods. This is particularly useful for subcommands that require specific permissions.\n * @remark This decorator applies to the client that is to execute the command. For setting permissions required user of the command see {@link RequiresUserPermissions}\n * @remark This decorator makes the decorated function asynchronous, so any result should be `await`ed.\n * @param permissionsResolvable Permissions that the method should have.\n * @example\n * ```typescript\n * import { ApplyOptions, RequiresClientPermissions } from '@sapphire/decorators';\n * import { Subcommand } from '@sapphire/plugin-subcommands';\n * import type { Message } from 'discord.js';\n *\n * (at)ApplyOptions<Subcommand.Options>({\n * \taliases: ['cws'],\n * \tdescription: 'A basic command with some subcommands',\n * \tsubCommands: ['add', 'remove', 'reset', { input: 'show', default: true }]\n * })\n * export default class extends Subcommand {\n *     // Anyone should be able to view the result, but not modify\n * \tpublic async show(message: Message) {\n * \t\treturn message.channel.send('Showing!');\n * \t}\n *\n * \t(at)RequiresClientPermissions('BAN_MEMBERS') // This subcommand requires the client to be able to ban members.\n * \tpublic async add(message: Message) {\n * \t\treturn message.channel.send('Adding!');\n * \t}\n *\n * \t(at)RequiresClientPermissions('BAN_MEMBERS') // This subcommand requires the client to be able to ban members.\n * \tpublic async remove(message: Message) {\n * \t\treturn message.channel.send('Removing!');\n * \t}\n *\n * \t(at)RequiresClientPermissions('BAN_MEMBERS') // This subcommand requires the client to be able to ban members.\n * \tpublic async reset(message: Message) {\n * \t\treturn message.channel.send('Resetting!');\n * \t}\n * }\n * ```\n */\nexport const RequiresClientPermissions = (...permissionsResolvable: PermissionResolvable[]): MethodDecorator => {\n\tconst resolved = new PermissionsBitField(permissionsResolvable);\n\tconst resolvedIncludesServerPermissions = Boolean(resolved.bitfield & DMAvailablePermissions.bitfield);\n\n\treturn createFunctionPrecondition((context: Message | BaseInteraction) => {\n\t\tconst { channel } = context;\n\t\tconst member = context.guild?.members.me;\n\n\t\tif (resolvedIncludesServerPermissions && isDMChannel(channel)) {\n\t\t\tthrow new UserError({\n\t\t\t\tidentifier: DecoratorIdentifiers.RequiresClientPermissionsGuildOnly,\n\t\t\t\tmessage: 'Sorry, but that command can only be used in a server because I do not have sufficient permissions in DMs'\n\t\t\t});\n\t\t}\n\n\t\tif (isGuildBasedChannel(channel) && !isNullish(member)) {\n\t\t\tconst missingPermissions = channel.permissionsFor(member).missing(resolved);\n\n\t\t\tif (missingPermissions.length) {\n\t\t\t\tthrow new UserError({\n\t\t\t\t\tidentifier: DecoratorIdentifiers.RequiresClientPermissionsMissingPermissions,\n\t\t\t\t\tmessage: `Sorry, but I am not allowed to do that. I am missing the permissions: ${missingPermissions}`,\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\tmissing: missingPermissions\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t});\n};\n\n/**\n * Allows you to set permissions required for individual methods. This is particularly useful for subcommands that require specific permissions.\n * @remark This decorator applies to the user of the command. For setting permissions required for the client see {@link RequiresClientPermissions}\n * @remark This decorator makes the decorated function asynchronous, so any result should be `await`ed.\n * @param permissionsResolvable Permissions that the method should have.\n * @example\n * ```typescript\n * import { ApplyOptions, RequiresUserPermissions } from '@sapphire/decorators';\n * import { Subcommand } from '@sapphire/plugin-subcommands';\n * import type { Message } from 'discord.js';\n *\n * (at)ApplyOptions<Subcommand.Options>({\n * \taliases: ['cws'],\n * \tdescription: 'A basic command with some subcommands',\n * \tsubCommands: ['add', 'remove', 'reset', { input: 'show', default: true }]\n * })\n * export default class extends Subcommand {\n *     // Anyone should be able to view the result, but not modify\n * \tpublic async show(message: Message) {\n * \t\treturn message.channel.send('Showing!');\n * \t}\n *\n * \t(at)RequiresUserPermissions('BAN_MEMBERS') // This subcommand requires the user of the command to be able to ban members.\n * \tpublic async add(message: Message) {\n * \t\treturn message.channel.send('Adding!');\n * \t}\n *\n * \t(at)RequiresUserPermissions('BAN_MEMBERS') // This subcommand requires the user of the command to be able to ban members.\n * \tpublic async remove(message: Message) {\n * \t\treturn message.channel.send('Removing!');\n * \t}\n *\n * \t(at)RequiresUserPermissions('BAN_MEMBERS') // This subcommand requires the user of the command to be able to ban members.\n * \tpublic async reset(message: Message) {\n * \t\treturn message.channel.send('Resetting!');\n * \t}\n * }\n * ```\n */\nexport const RequiresUserPermissions = (...permissionsResolvable: PermissionResolvable[]): MethodDecorator => {\n\tconst resolved = new PermissionsBitField(permissionsResolvable);\n\tconst resolvedIncludesServerPermissions = Boolean(resolved.bitfield & DMAvailableUserPermissions.bitfield);\n\n\treturn createFunctionPrecondition((context: Message | BaseInteraction) => {\n\t\tconst { channel } = context;\n\t\tconst member = context.guild?.members.me;\n\n\t\tif (resolvedIncludesServerPermissions && isDMChannel(channel)) {\n\t\t\tthrow new UserError({\n\t\t\t\tidentifier: DecoratorIdentifiers.RequiresUserPermissionsGuildOnly,\n\t\t\t\tmessage: 'Sorry, but that command can only be used in a server because you do not have sufficient permissions in DMs'\n\t\t\t});\n\t\t}\n\n\t\tif (isGuildBasedChannel(channel) && !isNullish(member)) {\n\t\t\tconst missingPermissions = channel.permissionsFor(member).missing(resolved);\n\n\t\t\tif (missingPermissions.length) {\n\t\t\t\tthrow new UserError({\n\t\t\t\t\tidentifier: DecoratorIdentifiers.RequiresUserPermissionsMissingPermissions,\n\t\t\t\t\tmessage: `Sorry, but you are not allowed to do that. You are missing the permissions: ${missingPermissions}`,\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\tmissing: missingPermissions\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t});\n};\n\n/**\n * Requires the message to be run in a guild context, this decorator requires the first argument to be a {@link Message} or {@link BaseInteraction} instance which includes all interaction types\n * @since 1.0.0\n * @param fallback The fallback value passed to {@link createFunctionPrecondition}\n */\nexport function RequiresGuildContext(fallback: FunctionFallback = (): void => undefined): MethodDecorator {\n\treturn createFunctionPrecondition((context: Message | BaseInteraction) => context.guild !== null, fallback);\n}\n\n/**\n * Requires the message to be run in a dm context, this decorator requires the first argument to be a {@link Message} or {@link BaseInteraction} instance which includes all interaction types\n * @since 1.0.0\n * @param fallback The fallback value passed to {@link createFunctionPrecondition}\n */\nexport function RequiresDMContext(fallback: FunctionFallback = (): void => undefined): MethodDecorator {\n\treturn createFunctionPrecondition((context: Message | BaseInteraction) => context.guild === null, fallback);\n}\n","import { container, type Piece } from '@sapphire/framework';\nimport type { Container } from '@sapphire/pieces';\nimport type { Ctor } from '@sapphire/utilities';\nimport { createClassDecorator, createProxy } from './utils';\n\n/**\n * Decorator function that applies given options to any Sapphire piece\n * @param options The options to pass to the piece constructor\n * @example\n * ```typescript\n * import { ApplyOptions } from '@sapphire/decorators';\n * import { Command } from '@sapphire/framework';\n * import type { Message } from 'discord.js';\n *\n * @ApplyOptions<Command.Options>({\n *   description: 'ping pong',\n *   enabled: true\n * })\n * export class UserCommand extends Command {\n *   public override async messageRun(message: Message) {\n *     const msg = await message.channel.send('Ping?');\n *\n *     return msg.edit(\n *       `Pong! Client Latency ${Math.round(this.container.client.ws.ping)}ms. API Latency ${msg.createdTimestamp - message.createdTimestamp}ms.`\n *     );\n *   }\n * }\n * ```\n * @example\n * ```typescript\n * import { ApplyOptions } from '@sapphire/decorators';\n * import { Listener } from '@sapphire/framework';\n * import { GatewayDispatchEvents, GatewayMessageDeleteDispatch } from 'discord.js';\n *\n * @ApplyOptions<Listener.Options>(({ container }) => ({\n *   description: 'Handle Raw Message Delete events',\n *   emitter: container.client.ws,\n *   event: GatewayDispatchEvents.MessageDelete\n * }))\n * export class UserListener extends Listener {\n *   public override run(data: GatewayMessageDeleteDispatch['d']): void {\n *     if (!data.guild_id) return;\n *\n *     const guild = this.container.client.guilds.cache.get(data.guild_id);\n *     if (!guild || !guild.channels.cache.has(data.channel_id)) return;\n *\n *     // Do something with the data\n *   }\n * }\n * ```\n */\nexport function ApplyOptions<T extends Piece.Options>(optionsOrFn: T | ((parameters: ApplyOptionsCallbackParameters) => T)): ClassDecorator {\n\treturn createClassDecorator((target: Ctor<ConstructorParameters<typeof Piece>, Piece>) =>\n\t\tcreateProxy(target, {\n\t\t\tconstruct: (ctor, [context, baseOptions = {}]: [Piece.Context, Piece.Options]) =>\n\t\t\t\tnew ctor(context, {\n\t\t\t\t\t...baseOptions,\n\t\t\t\t\t...(typeof optionsOrFn === 'function' ? optionsOrFn({ container, context }) : optionsOrFn)\n\t\t\t\t})\n\t\t})\n\t);\n}\n\nexport interface ApplyOptionsCallbackParameters {\n\tcontainer: Container;\n\tcontext: Piece.Context;\n}\n"]}